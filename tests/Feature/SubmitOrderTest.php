<?php

namespace Tests\Feature;

use App\Mail\Order\OrderCreatedMail;
use App\Models\Hmo;
use App\Models\Order;
use Carbon\Carbon;
use Database\Seeders\HmoSeeder;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Foundation\Testing\WithFaker;
use Tests\TestCase;
use Illuminate\Support\Facades\Mail;

class SubmitOrderTest extends TestCase
{
    use RefreshDatabase, WithFaker;

    protected $data;

    public function setUp(): void
    {
        parent::setup();

        $this->seed(HmoSeeder::class);
    }

    /**
     * test that all hmos can be retrieved
     *
     * @test
     * @return void
     */
    public function testGetAllHmos()
    {
        $response = $this->getJson('/api/hmos');

        $response->assertStatus(200);
        $response->assertJson(['status' => true, 'message' => 'Hmo(s) retrieved successfully', 'data' => Hmo::all()->toArray()]);
        $response->assertJsonCount(Hmo::count(), 'data');
    }

    /**
     * test that request is validated
     *
     * @test
     * @return void
     */
    public function testRequestValidation()
    {
        $orderData = [];

        $response = $this->postJson('/api/orders', $orderData);

        $response->assertStatus(422);

        $response->assertJsonFragment([
            'provider_name' => [
                'The provider name field is required.'
            ],
            'hmo_code' => [
                'The hmo code field is required.'
            ],
            'encounter_date' => [
                'The encounter date field is required.'
            ],
            'items' => [
                'The items field is required.'
            ]
        ]);

        $orderData = $this->getOrderData(['hmo_code' => 'test-code']);

        $response = $this->postJson('/api/orders', $orderData);

        $response->assertStatus(422);

        $response->assertJsonFragment([
            'hmo_code' => [
                'The selected hmo code is invalid.'
            ]
        ]);

        $orderData = $this->getOrderData(['encounter_date' => now()->addYear()->format('d-m-Y')]);

        $response = $this->postJson('/api/orders', $orderData);

        $response->assertStatus(422);

        $response->assertJsonFragment([
            'encounter_date' => [
                'The encounter date does not match the format Y-m-d.',
                'The encounter date must be a date before or equal to today.'
            ]
        ]);
    }

    /**
     * test that order can be created successfully
     *
     * @test
     * @return void
     */
    public function testCreateOrder()
    {
        $orderData = $this->getOrderData();
        $response = $this->postJson('/api/orders', $orderData);

        $response->assertStatus(200);
        $response->assertJson(['status' => true, 'message' => 'Order submitted successfully']);
        $this->assertDatabaseHas('orders', [
            'provider_name' => $orderData['provider_name'],
            'encounter_date' => $orderData['encounter_date'],
            'items' => json_encode($orderData['items']),
        ]);
    }

    /**
     * test that order created mail for hmo is queued successfully
     *
     * @test
     * @return void
     */
    public function testQueueOrderCreatedMail()
    {
        Mail::fake();

        $orderData = $this->getOrderData();
        $response = $this->postJson('/api/orders', $orderData);

        $response->assertStatus(200);

        $hmo = Hmo::where('code', $orderData['hmo_code'])->first();

        Mail::assertQueued(OrderCreatedMail::class, function ($mail) use ($hmo) {
            return $mail->hasTo($hmo->email);
        });
    }

    /**
     * test that order batch identifier is generated by encounter date successfully
     *
     * @test
     * @return void
     */
    public function testGenerateBatchIdentifierByEncounterDate()
    {
        $encounterDateHmo = Hmo::where('batch_criteria', Hmo::BATCH_CRITERIA_ENCOUNTER_DATE)->first();
        $date = now()->subDays(10)->format('Y-m-d');

        $orderData = $this->getOrderData(['hmo_code' =>  $encounterDateHmo->code, 'encounter_date' => $date]);

        $response = $this->postJson('/api/orders', $orderData);

        $response->assertStatus(200);

        $formatDate =  Carbon::parse($date)->format('M Y');
        $expectedBatchIdentifier = "{$orderData['provider_name']} {$formatDate}";

        $this->assertDatabaseHas('orders', [
            'provider_name' => $orderData['provider_name'],
            'encounter_date' => $orderData['encounter_date'],
            'items' => json_encode($orderData['items']),
            'batch_identifier' => $expectedBatchIdentifier
        ]);
        
    }

    /**
     * test that order batch identifier is generated by order date successfully
     *
     * @test
     * @return void
     */
    public function testGenerateBatchIdentifierByOrderDate()
    {;
        $orderDateHmo = Hmo::where('batch_criteria', Hmo::BATCH_CRITERIA_ORDER_DATE)->first();

        $orderData = $this->getOrderData(['hmo_code' =>  $orderDateHmo->code]);
        $response = $this->postJson('/api/orders', $orderData);

        $response->assertStatus(200);

        $order = Order::where('provider_name', $orderData['provider_name'])->where('encounter_date', $orderData['encounter_date'])
            ->where('hmo_id', $orderDateHmo->id)->where('items', json_encode($orderData['items']))->first();

        $formatDate =  Carbon::parse($order->created_at)->format('M Y');
        $expectedBatchIdentifier = "{$orderData['provider_name']} {$formatDate}";

        $this->assertDatabaseHas('orders', [
            'provider_name' => $orderData['provider_name'],
            'encounter_date' => $orderData['encounter_date'],
            'items' => json_encode($orderData['items']),
            'batch_identifier' => $expectedBatchIdentifier
        ]);
    }

    /**
     * get order data
     *
     * @return array
     */
    protected function getOrderData($data = [])
    {
        $orderData = [
            'provider_name' => $data['provider_name'] ?? $this->faker->name,
            'hmo_code' => $data['hmo_code'] ?? Hmo::inRandomOrder()->first()->code,
            'encounter_date' => $data['encounter_date'] ?? $this->faker->date,
            'items' => [
                [
                    'item' => $this->faker->name,
                    'unit_price' => $this->faker->randomFloat(2, 1),
                    'quantity' => $this->faker->numberBetween(10, 50),
                ],
            ]
        ];

        return $orderData;
    }
}